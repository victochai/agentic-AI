import openai
import replicate
import os
from dotenv import load_dotenv
load_dotenv()
from typing import List
import requests
import json
import random
from typing import Dict, Any
from openai.types.chat.chat_completion import ChatCompletion


def download_image(url: str, save_path: str = "image.jpg") -> str:
    response = requests.get(url)
    response.raise_for_status()  # Raises an error if download failed
    with open(save_path, "wb") as f:
        f.write(response.content)
    return save_path

def load_json(path: str) -> Dict[str, Any]:
    """
    This function loads a JSON file from the given path.
    """
    if not os.path.exists(path):
        raise FileNotFoundError(f"JSON file not found at {path}. Please check the path and try again.")
    with open(path, "r", encoding="utf-8") as f:
        return json.load(f)


def load_md(path: str) -> str:
    """
    This function loads a markdown file from the given path.
    """
    if not os.path.exists(path):
        raise FileNotFoundError(f"Markdown file not found at {path}. Please check the path and try again.")
    with open(path, "r", encoding="utf-8") as f:
        return f.read()


def get_random_welcome(welcome_system_prompt: str) -> str:
    """
    This function generates a random welcome message for users providing ingredients.
    """
    messages = [
        {"role": "system", "content": welcome_system_prompt},
        {"role": "user",
            "content": "Write a short welcome message for users who are about to provide ingredients."
        }
    ]
    response = client.chat.completions.create(
        model="gpt-4o-mini",
        messages=messages,
        temperature=1.0,
        n=1
    )
    return response.choices[0].message.content


def get_recipe(
        user_prompt: str,
        persona_system_prompt: str,
        ) -> str:
    """
    This function takes user_prompt (which should contain a list of ingredients) and persona_system_prompt, and returns a recipe.
    This function does not call any tools, it just generates a recipe based on the ingredients and instructions.
    The output is a string containing the recipe text. It is then passed to the tool_call function to generate images if needed.
    """
    print(random.choice(["\nJust a sec...\n", "\nThinking...\n", "\nGive me a moment...\n", "\nCooking up something special...\n"]))
    prompt = f"Create a recipe using the ingredients provided in this prompt: {user_prompt}."
    messages = [
        {"role": "system", "content": persona_system_prompt},
        {"role": "user",   "content": prompt}
    ]
    response = client.chat.completions.create(
        model="gpt-4.1",
        messages=messages,
        temperature=1.0,
        n=1
    )
    return response


def tool_call(response: ChatCompletion, tool_system_prompt: str, tools: Dict[str, Any]) -> ChatCompletion:
    """
    This function takes a response from the get_recipe function and checks if it contains any tool calls.
    It does not call any tools itself, but prepares the response for the next step.
    """
    recipe_text = response.choices[0].message.content.strip()
    follow_up = client.chat.completions.create(
        model="gpt-4.1",
        messages=[
            {"role": "system", "content": tool_system_prompt},
            {"role": "user", "content": "Hereâ€™s the recipe you just wrote:\n\n" + recipe_text + "\n\nCall tools to generate the final dish image and useful step images."}
        ],
        tools=tools,
        tool_choice="auto"
    )
    if follow_up.choices[0].message.tool_calls is None or len(follow_up.choices[0].message.tool_calls) == 0:
        raise ValueError("No image generation tools were called. Make sure the recipe includes the necessary placeholders.")
    return follow_up


def generate_image(prompt: str) -> List[str]:
    """
    This function generates an image based on the provided prompt using the Replicate API.
    """
    if not prompt:
        raise ValueError("Trying to generate an image. Prompt cannot be empty.")
    # Call the Replicate API to generate the image
    output = replicate.run(
        "black-forest-labs/flux-1.1-pro-ultra",
        input={
            "raw": True,  # less synthetic, more natural aesthetic
            "prompt": prompt + "\n Realistic, high-quality, detailed, visually appealing.",
            "aspect_ratio": "3:2",
            "output_format": "jpg",
            "safety_tolerance": 3  # 0 --> paranoid, 3 --> relaxed
        }
    )
    return output


def handle_image_gen(response: ChatCompletion, tool_system_prompt: str, tools: List[Any]) -> List[str]:
    """
    This function takes a recipe (generated by get_recipe) and returs ???
    """
    follow_up = tool_call(response, tool_system_prompt, tools=tools)  # Call the tool if needed
    for call in follow_up.choices[0].message.tool_calls:
        args = json.loads(call.function.arguments)
        if call.function.name == "gen_image":
            image = generate_image(**args)
            save_path = download_image(image, save_path="final_dish.jpg")
            print(f"Image saved to {save_path}")


if __name__ == "__main__":

    OPENAI_API_KEY=os.getenv("OPENAI_API_KEY")
    REPLICATE_API_TOKEN = os.getenv("REPLICATE_API_TOKEN")
    if not OPENAI_API_KEY:
        raise ValueError("OPENAI API key not found. Please set the OPENAI_API_KEY in .env")
    if not REPLICATE_API_TOKEN:
        raise ValueError("REPLICATE API token not found. Please set the REPLICATE_API_TOKEN in .env")

    client = openai.OpenAI(api_key=OPENAI_API_KEY)

    # Load system prompts and tools
    welcome_md = load_md(path=os.path.join("system_prompts", "welcome.md"))
    persona_md = load_md(path=os.path.join("system_prompts", "persona.md"))
    tools_md = load_md(path=os.path.join("system_prompts", "tools.md"))

    # Load tools from JSOn file
    tools = load_json(path="tools.json")

    # Ask the use for instructions
    ingredients = input(get_random_welcome(welcome_md) + "\n\n") # Get ingredients from user input

    # Generate a recipe based on the ingredients
    response = get_recipe(ingredients, persona_md)
    print(response.choices[0].message.content)  # Print the recipe content

    # Generate images if needed
    handle_image_gen(response, tools_md, tools=tools)  # Generate images if needed
